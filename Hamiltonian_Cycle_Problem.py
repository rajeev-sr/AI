# -*- coding: utf-8 -*-
"""AI_lab2_12341700.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17fvVMB1tvdXLw56_Vep8DB9dTr4GLytv
"""

import heapq

class HamiltonianCycleFinder:
    def __init__(self, adjacency_matrix):
        self.graph = adjacency_matrix
        self.vertex_count = len(adjacency_matrix)
        self.start = 0

    def find_hamiltonian_cycle(self):
        path_so_far = [self.start]
        visited = {self.start}
        cost_so_far = 0
        estimated_cost = self.estimate_remaining_cost(visited)

        heap = []
        heapq.heappush(heap, (estimated_cost, cost_so_far, path_so_far, visited))

        best_cycle = None
        best_cost = float("inf")

        while heap:
            total_estimate, current_cost, current_path, visited_nodes = heapq.heappop(heap)
            last_vertex = current_path[-1]

            # If all vertices visited, check if we can return to start
            if len(current_path) == self.vertex_count:
                if self.graph[last_vertex][self.start] > 0:
                    cycle_cost = current_cost + self.graph[last_vertex][self.start]
                    if cycle_cost < best_cost:
                        best_cycle = current_path + [self.start]
                        best_cost = cycle_cost
                continue

            # Explore neighbors
            for next_vertex in range(self.vertex_count):
                if self.graph[last_vertex][next_vertex] > 0 and next_vertex not in visited_nodes:
                    new_path = current_path + [next_vertex]
                    new_visited = visited_nodes | {next_vertex}
                    new_cost = current_cost + self.graph[last_vertex][next_vertex]
                    new_estimate = new_cost + self.estimate_remaining_cost(new_visited)
                    heapq.heappush(heap, (new_estimate, new_cost, new_path, new_visited))

        return best_cycle, best_cost if best_cycle else (None, None)

    def estimate_remaining_cost(self, visited):
        # Simple heuristic: assume at least min edge cost * remaining vertices
        remaining = set(range(self.vertex_count)) - visited
        if not remaining:
            return 0
        min_edge = float("inf")
        for u in range(self.vertex_count):
            for v in range(self.vertex_count):
                if u != v and self.graph[u][v] > 0:
                    min_edge = min(min_edge, self.graph[u][v])
        return len(remaining) * (min_edge if min_edge != float("inf") else 1)


def build_adjacency_matrix(vertices, edges):
    matrix = [[0] * vertices for _ in range(vertices)]
    for u, v, w in edges:
        matrix[u-1][v-1] = w
        matrix[v-1][u-1] = w  # undirected
    return matrix


def main():
    vertices = 4
    edges = [
        (1, 2, 10),
        (2, 3, 15),
        (3, 4, 20),
        (4, 1, 25),
        (1, 3, 35),
        (2, 4, 30)
    ]

    adjacency_matrix = build_adjacency_matrix(vertices, edges)
    solver = HamiltonianCycleFinder(adjacency_matrix)
    cycle, min_cost = solver.find_hamiltonian_cycle()

    if cycle:
        print("Hamiltonian cycle found with minimum cost:")
        print(" -> ".join(str(v + 1) for v in cycle))
        print("Total cost:", min_cost)
    else:
        print("No Hamiltonian cycle exists.")


if __name__ == "__main__":
    main()

import heapq

# function to build adjacency matrix
def build_adjacency_matrix(vertices, edges):
    mat = [[0] * vertices for _ in range(vertices)]
    for u, v, w in edges:
        mat[u-1][v-1] = w
        mat[v-1][u-1] = w   # since undirected graph
    return mat

# heuristic to guess remaining cost
def estimate_remaining_cost(graph, visited):
    n = len(graph)
    remaining = set(range(n)) - visited
    if not remaining:
        return 0

    # take minimum edge weight
    min_edge = float("inf")
    for i in range(n):
        for j in range(n):
            if i != j and graph[i][j] > 0:
                min_edge = min(min_edge, graph[i][j])
    if min_edge == float("inf"):
        min_edge = 1
    return len(remaining) * min_edge

# function to find Hamiltonian cycle using heuristic search (A* style)
def find_hamiltonian_cycle(graph):
    n = len(graph)
    start = 0
    path = [start]
    visited = {start}
    cost = 0
    est = estimate_remaining_cost(graph, visited)

    heap = []
    heapq.heappush(heap, (est, cost, path, visited))

    best_path = None
    best_cost = float("inf")

    while heap:
        total_est, cur_cost, cur_path, vis = heapq.heappop(heap)
        last = cur_path[-1]

        # if visited all nodes, try to return to start
        if len(cur_path) == n:
            if graph[last][start] > 0:
                cycle_cost = cur_cost + graph[last][start]
                if cycle_cost < best_cost:
                    best_cost = cycle_cost
                    best_path = cur_path + [start]
            continue

        # explore neighbors
        for nxt in range(n):
            if graph[last][nxt] > 0 and nxt not in vis:
                new_path = cur_path + [nxt]
                new_vis = vis | {nxt}
                new_cost = cur_cost + graph[last][nxt]
                new_est = new_cost + estimate_remaining_cost(graph, new_vis)
                heapq.heappush(heap, (new_est, new_cost, new_path, new_vis))

    if best_path:
        return best_path, best_cost
    return None, None

# main part
if __name__ == "__main__":
    vertices = 5
    edges = [
        (1, 2, 2),
        (2, 3, 3),
        (3, 4, 4),
        (4, 5, 5),
        (5, 1, 6),
        (1, 3, 7),
        (2, 4, 8),
        (3, 5, 9)
    ]

    graph = build_adjacency_matrix(vertices, edges)
    cycle, cost = find_hamiltonian_cycle(graph)

    if cycle:
        print("Hamiltonian cycle found:")
        print(" -> ".join(str(v+1) for v in cycle))
        print("Total cost:", cost)
    else:
        print("No Hamiltonian cycle exists.")

# main part
if __name__ == "__main__":
    vertices1 = 4
    edges1 = [
        (1, 2, 10),
        (2, 3, 15),
        (3, 4, 20),
        (4, 1, 25),
        (1, 3, 35),
        (2, 4, 30)
    ]

    graph = build_adjacency_matrix(vertices1, edges1)
    cycle, cost = find_hamiltonian_cycle(graph)

    if cycle:
        print("Hamiltonian cycle found:")
        print(" -> ".join(str(v+1) for v in cycle))
        print("Total cost:", cost)
    else:
        print("No Hamiltonian cycle exists.")

# main part
if __name__ == "__main__":
    vertices = 6
    edges = [
        (1, 2, 10),
        (2, 3, 12),
        (3, 4, 8),
        (4, 5, 15),
        (5, 6, 7),
        (6, 1, 9),
        (1, 3, 20),
        (2, 4, 25),
        (3, 5, 18),
        (4, 6, 11)
    ]

    graph = build_adjacency_matrix(vertices, edges)
    cycle, cost = find_hamiltonian_cycle(graph)

    if cycle:
        print("Hamiltonian cycle found:")
        print(" -> ".join(str(v+1) for v in cycle))
        print("Total cost:", cost)
    else:
        print("No Hamiltonian cycle exists.")